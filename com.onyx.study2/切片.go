package main

import "fmt"

/**
切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。
与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。
*/
func main() {

	//注意，被“切下”的部分不包含元素上界索引指向的元素。
	// 另外，切片表达式的求值结果会是切片类型的，且其元素类型与被“切片”的值的元素类型一致。
	var num = [5]int{1, 2, 3, 4, 5}
	var slice1 = num[1:3] //2,3

	//一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值。
	//为了获取数组、切片或通道类型的值的容量，我们可以使用内建函数cap
	fmt.Println(slice1, cap(slice1))

	//最后，要注意，切片类型属于引用类型。它的零值即为nil，即空值。
	// 如果我们只声明一个切片类型的变量而不为它赋值，那么该变量的值将会是nil
	var sli []int
	fmt.Println(sli, cap(sli))

	//这第三个正整数被称为容量上界索引。它的意义在于可以把作为结果的切片值的容量设置得更小。
	// 换句话说，它可以限制我们通过这个切片值对其底层数组中的更多元素的访问。
	var sli2 = num[1:4:4]
	fmt.Println(sli2)

	//append会对切片值进行扩展并返回一个新的切片值
	var sli3 = append(slice1, 5, 6, 9)
	fmt.Println(sli3)

	/**
		该操作的实施方法是调用copy函数。该函数接受两个类型相同的切片值作为参数，并会把第二个参数值中的元素复制到第一个参数值中的相应位置（索引值相同）上。这里有两点需要注意：

	  1. 这种复制遵循最小复制原则，即：被复制的元素的个数总是等于长度较短的那个参数值的长度。
	  2. 与append函数不同，copy函数会直接对其第一个参数值进行修改。
	*/

}
